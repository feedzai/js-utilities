"use strict";(globalThis.webpackChunk_feedzai_js_utilities_docs=globalThis.webpackChunk_feedzai_js_utilities_docs||[]).push([[2959],{3599:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>s,toc:()=>c});var o=a(4848),r=a(8453);const t={title:"makeCancelable"},l=void 0,s={id:"functions/utils/make-cancelable",title:"makeCancelable",description:"Wraps a native Promise and allows it to be cancelled using AbortController. This is useful for cancelling long-running operations or preventing memory leaks when a component unmounts before an async operation completes. The function also provides access to the underlying AbortSignal, which can be used to coordinate cancellation across multiple promises or network requests.",source:"@site/docs/functions/utils/make-cancelable.mdx",sourceDirName:"functions/utils",slug:"/functions/utils/make-cancelable",permalink:"/js-utilities/docs/functions/utils/make-cancelable",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"makeCancelable"},sidebar:"tutorialSidebar",previous:{title:"emptyFunction",permalink:"/js-utilities/docs/functions/utils/empty-function"},next:{title:"throwError",permalink:"/js-utilities/docs/functions/utils/throw-error"}},i={},c=[{value:"API",id:"api",level:2},{value:"Usage",id:"usage",level:3},{value:"React Example",id:"react-example",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Coordinating Multiple Operations",id:"coordinating-multiple-operations",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Wraps a native Promise and allows it to be cancelled using AbortController. This is useful for cancelling long-running operations or preventing memory leaks when a component unmounts before an async operation completes. The function also provides access to the underlying AbortSignal, which can be used to coordinate cancellation across multiple promises or network requests."}),"\n",(0,o.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface MakeCancelablePromise<T = unknown> {\n  /**\n   * The wrapped promise that can be aborted\n   */\n  promise: Promise<T>;\n\n  /**\n   * Aborts the promise execution. Safe to call multiple times - subsequent calls will be ignored if already cancelled.\n   * @param reason - Optional reason for the cancellation\n   */\n  cancel: (reason?: any) => void;\n\n  /**\n   * Checks whether the promise has been cancelled\n   */\n  isCancelled: () => boolean;\n\n  /**\n   * The AbortSignal object that can be used to check if the promise has been cancelled.\n   * This signal can be used to coordinate cancellation across multiple promises or network requests\n   * by passing it to other abortable operations that should be cancelled together.\n   */\n  signal: AbortSignal;\n}\n\nfunction makeCancelable<T = unknown>(promise: Promise<T>): MakeCancelablePromise<T>;\n"})}),"\n",(0,o.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { makeCancelable, wait } from '@feedzai/js-utilities';\n\n// A Promise that resolves after 1 second\nconst somePromise = wait(1000);\n\n// Make it cancelable\nconst cancelable = makeCancelable(somePromise);\n\n// Execute the wrapped promise\ncancelable.promise\n  .then(console.log)\n  .catch(error => {\n    if (error instanceof AbortPromiseError) {\n      console.log('Promise was cancelled');\n    } else {\n      console.error('Other error:', error);\n    }\n  });\n\n// Cancel it when needed\ncancelable.cancel();\n\n// Check if already cancelled\nif (cancelable.isCancelled()) {\n  console.log('Promise was already cancelled');\n}\n\n// Use the signal with other abortable operations\nfetch('/api/data', { signal: cancelable.signal })\n  .then(response => response.json())\n  .catch(error => {\n    if (error instanceof AbortPromiseError) {\n      console.log('Fetch was cancelled');\n    }\n  });\n"})}),"\n",(0,o.jsx)(n.h3,{id:"react-example",children:"React Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { makeCancelable } from '@feedzai/js-utilities';\nimport { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    const cancelable = makeCancelable(fetchData());\n\n    // Use the signal with multiple operations\n    const fetchUser = fetch('/api/user', { signal: cancelable.signal });\n    const fetchSettings = fetch('/api/settings', { signal: cancelable.signal });\n\n    Promise.all([cancelable.promise, fetchUser, fetchSettings])\n      .then(([data, user, settings]) => {\n        setData(data);\n        setUser(user);\n        setSettings(settings);\n      })\n      .catch(error => {\n        if (error instanceof AbortPromiseError) {\n          // Handle cancellation\n          console.log('Data fetch was cancelled');\n        } else {\n          // Handle other errors\n          console.error('Error fetching data:', error);\n        }\n      });\n\n    // Cleanup on unmount\n    return () => cancelable.cancel();\n  }, []);\n\n  return <div>...</div>;\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsxs)(n.p,{children:["When a promise is cancelled, it rejects with an ",(0,o.jsx)(n.code,{children:"AbortPromiseError"}),". This error extends ",(0,o.jsx)(n.code,{children:"DOMException"})," and has the following properties:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"name"}),': "AbortError"']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"message"}),': "Promise was aborted"']}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["You can check for cancellation by using ",(0,o.jsx)(n.code,{children:"instanceof"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"try {\n  await cancelable.promise;\n} catch (error) {\n  if (error instanceof AbortPromiseError) {\n    // Handle cancellation\n  } else {\n    // Handle other errors\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"coordinating-multiple-operations",children:"Coordinating Multiple Operations"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"signal"})," property can be used to coordinate cancellation across multiple operations. This is particularly useful when you need to cancel multiple related operations together:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const cancelable = makeCancelable(fetchData());\n\n// Use the same signal for multiple operations\nconst operation1 = new Promise((resolve, reject) => {\n  cancelable.signal.addEventListener('abort', () => {\n    reject(new AbortPromiseError());\n  });\n  // ... operation logic\n});\n\nconst operation2 = new Promise((resolve, reject) => {\n  cancelable.signal.addEventListener('abort', () => {\n    reject(new AbortPromiseError());\n  });\n  // ... operation logic\n});\n\n// Cancelling the original promise will also cancel all operations using its signal\ncancelable.cancel();\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>l,x:()=>s});var o=a(6540);const r={},t=o.createContext(r);function l(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);